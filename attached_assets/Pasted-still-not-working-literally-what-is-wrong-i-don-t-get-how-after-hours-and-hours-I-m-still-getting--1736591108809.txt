still not working. literally what is wrong? i don't get how after hours and hours I'm still getting this error.

how is our implementation different from the example stripe gives us for Express?
@https://github.com/stripe/stripe-node/blob/master/examples/webhook-signing/express/main.ts 
@https://github.com/stripe/stripe-node/blob/master/examples/webhook-signing/express/package.json 

server/stripe.js:
import { Stripe } from 'stripe';
import { db, where, schema } from '../db';
const { users } = schema;
// Validate required environment variables
if (!process.env.STRIPE_SECRET_KEY) {
    throw new Error('Missing STRIPE_SECRET_KEY');
}
// Initialize Stripe with proper typing
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
    apiVersion: '2023-10-16',
    typescript: true
});
// Log initialization status (without exposing sensitive data)
console.log('Stripe initialized successfully:', {
    apiVersion: '2023-10-16',
    secretKeyPrefix: process.env.STRIPE_SECRET_KEY?.substring(0, 8) + '...',
    webhookConfigured: process.env.STRIPE_WEBHOOK_SECRET ? '✓' : '✗'
});
// Price IDs for your products
const PRICES = {
    MONTHLY: process.env.STRIPE_TEST_PRICE_MONTHLY,
    YEARLY: process.env.STRIPE_TEST_PRICE_YEARLY,
};
// Validate price IDs
if (!PRICES.MONTHLY || !PRICES.YEARLY) {
    console.warn('Stripe price IDs not configured, checkout will not work:', {
        monthly: PRICES.MONTHLY ? 'configured' : 'missing',
        yearly: PRICES.YEARLY ? 'configured' : 'missing'
    });
}
export async function createCheckoutSession(userId, priceType = 'monthly') {
    try {
        const [user] = await db
            .select()
            .from(users)
            .where(where(users.id, userId))
            .limit(1);
        if (!user) {
            throw new Error('User not found');
        }
        const priceId = priceType === 'yearly' ? PRICES.YEARLY : PRICES.MONTHLY;
        console.log('Price IDs configuration:', {
            monthly: PRICES.MONTHLY || 'missing',
            yearly: PRICES.YEARLY || 'missing',
            requested: priceType,
            selectedPriceId: priceId
        });
        // Validate price ID
        if (!priceId) {
            throw new Error(`Price ID not found for ${priceType} subscription`);
        }
        // Get client URL from environment or use appropriate default
        const clientUrl = process.env.CLIENT_URL ||
            (process.env.REPL_ID // Check if running on Replit
                ? 'https://endorsehub.com' // Use replit URL on Replit
                : 'http://localhost:5173'); // Use localhost otherwise
        // Create a checkout session
        console.log('Creating Stripe checkout session with config:', {
            priceId,
            userEmail: user.email,
            userId: user.id,
            successUrl: `${clientUrl}/dashboard?payment=success&session_id={CHECKOUT_SESSION_ID}`,
            cancelUrl: `${clientUrl}/dashboard?payment=cancelled`
        });
        const session = await stripe.checkout.sessions.create({
            payment_method_types: ['card'],
            line_items: [
                {
                    price: priceId,
                    quantity: 1,
                },
            ],
            mode: 'subscription',
            success_url: `${clientUrl}/dashboard?payment=success&session_id={CHECKOUT_SESSION_ID}`,
            cancel_url: `${clientUrl}/dashboard?payment=cancelled`,
            customer_email: user.email,
            metadata: {
                userId: user.id.toString(),
                priceType,
            },
            billing_address_collection: 'required',
            allow_promotion_codes: true,
            currency: 'usd',
        });
        console.log('Checkout session created:', {
            sessionId: session.id,
            url: session.url
        });
        return session;
    }
    catch (error) {
        console.error('Error creating checkout session:', error);
        throw error;
    }
}
export async function handleWebhook(req, res) {
    const sig = req.headers['stripe-signature'];
    if (!sig || !process.env.STRIPE_WEBHOOK_SECRET) {
        return res.status(400).json({ error: 'Missing signature or webhook secret' });
    }
    try {
        const event = stripe.webhooks.constructEvent(req.body, sig, process.env.STRIPE_WEBHOOK_SECRET);
        switch (event.type) {
            case 'checkout.session.completed': {
                const session = event.data.object;
                const userId = parseInt(session.metadata?.userId || '');
                if (userId) {
                    await db.update(users)
                        .set({
                        is_premium: true,
                        stripe_customer_id: session.customer
                    })
                        .where(where(users.id, userId));
                }
                break;
            }
            case 'customer.subscription.deleted': {
                const subscription = event.data.object;
                const customer = subscription.customer;
                await db.update(users)
                    .set({ is_premium: false })
                    .where(where(users.stripe_customer_id, customer));
                break;
            }
        }
        res.json({ received: true });
    }
    catch (error) {
        console.error('Webhook error:', error);
        res.status(400).json({ error: 'Webhook error' });
    }
}
export { stripe };

server/routes/billing.ts:
import { Router } from 'express';
import { db, where, schema } from '../../db';
import { stripe } from '../stripe';
import type { Request, Response } from 'express';

const { users } = schema;

const router = Router();

router.post('/api/billing/create-checkout-session', async (req: Request, res: Response) => {
  try {
    if (!req.user?.id) {
      return res.status(401).json({
        success: false,
        error: 'Authentication required'
      });
    }

    const session = await stripe.checkout.sessions.create({
      payment_method_types: ['card'],
      line_items: [
        {
          price: process.env.STRIPE_PRICE_ID,
          quantity: 1,
        },
      ],
      mode: 'subscription',
      success_url: `${process.env.CLIENT_URL}/dashboard?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${process.env.CLIENT_URL}/dashboard`,
      customer_email: req.user.email,
      metadata: {
        userId: req.user.id.toString()
      }
    });

    return res.json({
      success: true,
      data: {
        url: session.url
      }
    });
  } catch (error) {
    console.error('[Billing] Error creating checkout session:', error);
    return res.status(500).json({
      success: false,
      error: 'Failed to create checkout session'
    });
  }
});

export default router; 

server/routes/billing.js:
import { Router } from 'express';
import { schema } from '../../db';
import { stripe } from '../stripe';
const { users } = schema;
const router = Router();
router.post('/api/billing/create-checkout-session', async (req, res) => {
    try {
        if (!req.user?.id) {
            return res.status(401).json({
                success: false,
                error: 'Authentication required'
            });
        }
        const session = await stripe.checkout.sessions.create({
            payment_method_types: ['card'],
            line_items: [
                {
                    price: process.env.STRIPE_PRICE_ID,
                    quantity: 1,
                },
            ],
            mode: 'subscription',
            success_url: `${process.env.CLIENT_URL}/dashboard?session_id={CHECKOUT_SESSION_ID}`,
            cancel_url: `${process.env.CLIENT_URL}/dashboard`,
            customer_email: req.user.email,
            metadata: {
                userId: req.user.id.toString()
            }
        });
        return res.json({
            success: true,
            data: {
                url: session.url
            }
        });
    }
    catch (error) {
        console.error('[Billing] Error creating checkout session:', error);
        return res.status(500).json({
            success: false,
            error: 'Failed to create checkout session'
        });
    }
});
export default router;

server/routes/webhook.routes.ts:
import { Router } from "express";

export function setupWebhookRoutes(app: Router) {
  const router = Router();
  
  // Note: Stripe webhook is now handled in server/index.ts
  
  app.use('/webhooks', router);
  return router;
} 
server/stripe.ts:
import { Stripe } from 'stripe';
import type { Request, Response } from 'express';
import { db, where, schema } from '../db';
import { eq } from 'drizzle-orm';

const { users } = schema;

// Validate required environment variables
if (!process.env.STRIPE_SECRET_KEY) {
  throw new Error('Missing STRIPE_SECRET_KEY');
}

// Initialize Stripe with proper typing
const config = {
  apiVersion: '2023-10-16',
  typescript: true
} as const;

// Use type assertion to override Stripe's type checking
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, config as any);

// Log initialization status (without exposing sensitive data)
console.log('Stripe initialized successfully:', {
  apiVersion: '2023-10-16',
  secretKeyPrefix: process.env.STRIPE_SECRET_KEY?.substring(0, 8) + '...',
  webhookConfigured: process.env.STRIPE_WEBHOOK_SECRET ? '✓' : '✗'
});

// Price IDs for your products
const PRICES = {
  MONTHLY: process.env.STRIPE_TEST_PRICE_MONTHLY,
  YEARLY: process.env.STRIPE_TEST_PRICE_YEARLY,
} as const;

// Validate price IDs
if (!PRICES.MONTHLY || !PRICES.YEARLY) {
  console.warn('Stripe price IDs not configured, checkout will not work:', {
    monthly: PRICES.MONTHLY ? 'configured' : 'missing',
    yearly: PRICES.YEARLY ? 'configured' : 'missing'
  });
}

interface CreateCheckoutSessionBody {
  priceType: 'monthly' | 'yearly';
}

export async function createCheckoutSession(userId: number, priceType: 'monthly' | 'yearly' = 'monthly') {
  try {
    const [user] = await db
      .select()
      .from(users)
      .where(where(users.id, userId))
      .limit(1);

    if (!user) {
      throw new Error('User not found');
    }

    const priceId = priceType === 'yearly' ? PRICES.YEARLY : PRICES.MONTHLY;

    console.log('Price IDs configuration:', {
      monthly: PRICES.MONTHLY || 'missing',
      yearly: PRICES.YEARLY || 'missing',
      requested: priceType,
      selectedPriceId: priceId
    });

    // Validate price ID
    if (!priceId) {
      throw new Error(`Price ID not found for ${priceType} subscription`);
    }

    // Get client URL from environment or use appropriate default
    const clientUrl = process.env.CLIENT_URL || 
      (process.env.REPL_ID  // Check if running on Replit
        ? 'https://endorsehub.com'  // Use replit URL on Replit
        : 'http://localhost:5173');        // Use localhost otherwise

    // Create a checkout session
    console.log('Creating Stripe checkout session with config:', {
      priceId,
      userEmail: user.email,
      userId: user.id,
      successUrl: `${clientUrl}/dashboard?payment=success&session_id={CHECKOUT_SESSION_ID}`,
      cancelUrl: `${clientUrl}/dashboard?payment=cancelled`
    });

    const session = await stripe.checkout.sessions.create({
      payment_method_types: ['card'],
      line_items: [
        {
          price: priceId,
          quantity: 1,
        },
      ],
      mode: 'subscription',
      success_url: `${clientUrl}/dashboard?payment=success&session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${clientUrl}/dashboard?payment=cancelled`,
      customer_email: user.email,
      metadata: {
        userId: user.id.toString(),
        priceType,
      },
      billing_address_collection: 'required',
      allow_promotion_codes: true,
      currency: 'usd',
    });

    console.log('Checkout session created:', { 
      sessionId: session.id,
      url: session.url 
    });

    return session;
  } catch (error) {
    console.error('Error creating checkout session:', error);
    throw error;
  }
}

export async function handleWebhook(req: Request, res: Response) {
  try {
    const sig = req.headers['stripe-signature'];
    if (!sig || !process.env.STRIPE_WEBHOOK_SECRET) {
      throw new Error('Missing signature or webhook secret');
    }

    const event = stripe.webhooks.constructEvent(
      req.body, // Use the raw body directly
      sig,
      process.env.STRIPE_WEBHOOK_SECRET
    );

    console.log('[Stripe Webhook] Processing event:', {
      type: event.type,
      id: event.id
    });

    switch (event.type) {
      case 'checkout.session.completed': {
        const session = event.data.object as Stripe.Checkout.Session;
        const userId = parseInt(session.metadata?.userId || '');
        
        if (!userId) {
          console.error('[Stripe Webhook] Missing userId in session metadata', session.metadata);
          return res.status(400).json({ error: 'Missing userId in session metadata' });
        }

        console.log('[Stripe Webhook] Processing completed checkout:', {
          userId,
          customerId: session.customer,
          subscriptionId: session.subscription,
          metadata: session.metadata
        });

        await db.update(users)
          .set({
            is_premium: true,
            stripe_customer_id: session.customer as string,
            stripeSubscriptionId: session.subscription as string
          })
          .where(eq(users.id, userId));

        console.log('[Stripe Webhook] User premium status updated successfully');
        break;
      }
      case 'customer.subscription.deleted': {
        const subscription = event.data.object as Stripe.Subscription;
        const customer = subscription.customer as string;
        
        console.log('[Stripe Webhook] Processing subscription deletion:', {
          customer,
          subscriptionId: subscription.id
        });

        await db.update(users)
          .set({ 
            is_premium: false,
            stripeSubscriptionId: null
          })
          .where(eq(users.stripe_customer_id, customer));

        console.log('[Stripe Webhook] User premium status revoked successfully');
        break;
      }
      default: {
        console.log('[Stripe Webhook] Unhandled event type:', event.type);
      }
    }

    return res.json({ received: true });
  } catch (error) {
    console.error('[Stripe Webhook] Error processing webhook:', error);
    return res.status(400).json({ 
      error: 'Webhook error',
      message: error instanceof Error ? error.message : 'Unknown error'
    });
  }
}

export { stripe };

server/index.ts:
import express, { Request, Response, NextFunction } from 'express';
import cors from 'cors';
import path from 'path';
import { fileURLToPath } from 'url';
import { setupAuthRoutes } from './routes/auth.routes';
import { setupTestimonialRoutes } from './routes/testimonial.routes';
import { setupAnalyticsRoutes } from './routes/analytics.routes';
import { setupStripeRoutes } from './routes/stripe.routes';
import { setupWidgetRoutes } from './routes/widget.routes';
import { setupStatsRoutes } from './routes/stats.routes';
import { handleWebhook } from './stripe';
import passport from 'passport';
import session from 'express-session';
import MemoryStore from 'memorystore';
import { Strategy as LocalStrategy } from 'passport-local';
import bcrypt from 'bcrypt';
import { db, setupDb } from "./db";
import { users } from "@db/schema";
import { sql, eq } from "drizzle-orm";
import type { Stripe } from 'stripe';

// Extend Express Request type to include rawBody
declare global {
  namespace Express {
    interface Request {
      rawBody?: Buffer;
    }
  }
}

// ES Module fix for __dirname
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function startServer() {
  // Initialize database and run migrations before any server setup
  try {
    console.log('[Server] Setting up database...');
    await setupDb();
    console.log('[Server] Database setup completed successfully');
  } catch (error) {
    console.error('[Server] Database setup failed:', error);
    console.error('[Server] Cannot proceed with server startup due to database initialization failure');
    process.exit(1);
  }

  // Only proceed with server setup if database initialization was successful
  const app = express();

  // Configure Passport's Local Strategy
  passport.use(new LocalStrategy({
    usernameField: 'email',
    passwordField: 'password'
  }, async (email, password, done) => {
    try {
      console.log('[Passport] Authenticating user:', { email });
      const result = await db
        .select()
        .from(users)
        .where(sql`LOWER(${users.email}) = LOWER(${email})`)
        .limit(1);
      
      const user = result[0];

      if (!user) {
        console.log('[Passport] User not found:', { email });
        return done(null, false, { message: 'Invalid email or password.' });
      }

      const isValid = await bcrypt.compare(password, user.password);
      if (!isValid) {
        console.log('[Passport] Invalid password:', { email });
        return done(null, false, { message: 'Invalid email or password.' });
      }

      // Remove password from user object before serializing
      const { password: _, ...userWithoutPassword } = user;
      console.log('[Passport] Authentication successful:', { userId: user.id });
      return done(null, userWithoutPassword);
    } catch (err) {
      console.error('[Passport] Authentication error:', err);
      return done(err);
    }
  }));

  // Serialize user for the session
  passport.serializeUser((user: any, done) => {
    console.log('[Passport] Serializing user:', { userId: user.id });
    done(null, user.id);
  });

  // Deserialize user from the session
  passport.deserializeUser(async (id: number, done) => {
    try {
      console.log('[Passport] Deserializing user:', { userId: id });
      const result = await db
        .select()
        .from(users)
        .where(eq(users.id, id))
        .limit(1);
      
      if (!result[0]) {
        console.log('[Passport] User not found during deserialization:', { userId: id });
        return done(null, false);
      }
      
      // Remove password before returning
      const { password: _, ...userWithoutPassword } = result[0];
      console.log('[Passport] User deserialized successfully:', { userId: id });
      done(null, userWithoutPassword);
    } catch (err) {
      console.error('[Passport] Deserialization error:', err);
      done(err);
    }
  });

  // CORS configuration
  const allowedOrigins: (string | RegExp)[] = [
    'http://localhost:5173',
    'http://localhost:3001',
    'http://0.0.0.0:5173',
    'http://0.0.0.0:3001',
    'http://172.31.196.3:5173',
    'http://172.31.196.62:5173',
    'http://172.31.196.85:5173',
    'http://172.31.196.5:5173',
    'https://endorsehub.replit.app',
    'https://endorsehub.com',
    'https://www.endorsehub.com',
    /\.replit\.dev$/,
    /\.replit\.app$/,
    /^https?:\/\/.*\.worf\.replit\.dev(:\d+)?$/
  ];

  // Add CLIENT_URL if it exists
  if (process.env.CLIENT_URL) {
    allowedOrigins.push(process.env.CLIENT_URL);
  }

  const corsOptions: cors.CorsOptions = {
    origin: (origin, callback) => {
      // Allow requests with no origin (like mobile apps, curl requests, or same-origin)
      if (!origin) {
        return callback(null, true);
      }

      // Check if the origin is allowed
      const isAllowed = allowedOrigins.some(allowed => {
        if (typeof allowed === 'string') {
          return allowed === origin;
        }
        // For RegExp, test the origin
        return allowed.test(origin);
      });

      if (isAllowed) {
        callback(null, true);
      } else {
        console.warn(`[CORS] Blocked request from origin: ${origin}`);
        callback(new Error('Not allowed by CORS'));
      }
    },
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'Cookie', 'stripe-signature'],
    exposedHeaders: ['Set-Cookie'],
    maxAge: 86400 // 24 hours in seconds
  };

  // Configure CORS first
  app.use(cors(corsOptions));

  // Stripe webhook route must come before body parsers
  app.post('/api/billing/webhook', express.raw({type: 'application/json'}), async (req: Request, res: Response) => {
    console.log('[Stripe Webhook] Received webhook request:', {
      path: req.path,
      method: req.method,
      hasSignature: !!req.headers['stripe-signature'],
      contentType: req.headers['content-type'],
      bodyType: typeof req.body,
      bodyLength: req.body?.length
    });

    try {
      await handleWebhook(req, res);
    } catch (error) {
      console.error('[Stripe Webhook] Error:', error);
      return res.status(400).json({ 
        error: 'Webhook error',
        message: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Configure body parsing middleware for all other routes
  app.use(express.json());
  app.use(express.urlencoded({ extended: true }));

  // Session setup
  const MemoryStoreSession = MemoryStore(session);
  const sessionConfig: session.SessionOptions = {
    secret: process.env.SESSION_SECRET || 'your-secret-key',
    name: 'testimonial.sid',
    resave: false,
    saveUninitialized: false,
    rolling: true,
    store: new MemoryStoreSession({
      checkPeriod: 86400000
    }),
    cookie: {
      secure: process.env.NODE_ENV === 'production',
      httpOnly: true,
      sameSite: 'lax',
      maxAge: 24 * 60 * 60 * 1000,
      path: '/'
    }
  };

  // In production, ensure secure cookies and trust proxy
  if (process.env.NODE_ENV === 'production') {
    app.set('trust proxy', 1);
    app.enable('trust proxy');
  }

  app.use(session(sessionConfig));

  // Initialize Passport
  app.use(passport.initialize());
  app.use(passport.session());

  // Debug middleware for all requests
  app.use((req, res, next) => {
    console.log('[Server] Request:', {
      method: req.method,
      path: req.path,
      origin: req.get('origin'),
      authenticated: req.isAuthenticated(),
      userId: req.user?.id,
      sessionId: req.session?.id,
      body: req.path.includes('password') ? '[REDACTED]' : req.body // Log body except for password
    });
    next();
  });

  // API routes
  console.log('[Server] Setting up API routes...');
  const apiRouter = express.Router();

  // Create a new router for other API routes
  setupAuthRoutes(apiRouter);
  setupTestimonialRoutes(apiRouter);
  setupAnalyticsRoutes(apiRouter);
  setupStripeRoutes(apiRouter);
  setupWidgetRoutes(apiRouter);
  setupStatsRoutes(apiRouter);

  // Mount other API routes
  app.use('/api', apiRouter);
  console.log('[Server] API routes mounted at /api');

  // Serve static files from the client build directory
  const clientDistPath = path.join(__dirname, '..', 'client', 'dist');
  app.use(express.static(clientDistPath));

  // SPA fallback - this must come after API routes
  app.get('*', (req, res) => {
    // Don't handle /api routes here
    if (req.path.startsWith('/api/')) {
      return res.status(404).json({ 
        success: false, 
        error: 'API endpoint not found' 
      });
    }
    res.sendFile(path.join(clientDistPath, 'index.html'));
  });

  // Error handling middleware - should be last
  app.use((err: any, req: any, res: any, next: any) => {
    console.error('[Server] Error:', err);
    res.status(err.status || 500).json({ 
      success: false,
      error: err.message || 'Internal Server Error'
    });
  });

  const port = parseInt(process.env.PORT || '3001', 10);
  app.listen(port, '0.0.0.0', () => {
    console.log(`[Server] API Server running at http://0.0.0.0:${port}`);
  });
}

// Improve error handling in the main startup function
process.on('unhandledRejection', (reason, promise) => {
  console.error('[Server] Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

startServer().catch(error => {
  console.error('[Server] Fatal startup error:', error);
  process.exit(1);
});

server/index.js:
import express from 'express';
import cors from 'cors';
import path from 'path';
import { fileURLToPath } from 'url';
import { setupAuthRoutes } from './routes/auth.routes';
import { setupTestimonialRoutes } from './routes/testimonial.routes';
import { setupAnalyticsRoutes } from './routes/analytics.routes';
import { setupStripeRoutes } from './routes/stripe.routes';
import { setupWidgetRoutes } from './routes/widget.routes';
import { setupStatsRoutes } from './routes/stats.routes';
import passport from 'passport';
import session from 'express-session';
import MemoryStore from 'memorystore';
import { Strategy as LocalStrategy } from 'passport-local';
import bcrypt from 'bcrypt';
import { db, setupDb } from "./db";
import { users } from "@db/schema";
import { sql } from "drizzle-orm";
import { eq } from "drizzle-orm/sql";
import { handleWebhook } from './stripe';
// ES Module fix for __dirname
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
async function startServer() {
    // Initialize database and run migrations before any server setup
    try {
        console.log('[Server] Setting up database...');
        await setupDb();
        console.log('[Server] Database setup completed successfully');
    }
    catch (error) {
        console.error('[Server] Database setup failed:', error);
        console.error('[Server] Cannot proceed with server startup due to database initialization failure');
        process.exit(1);
    }
    // Only proceed with server setup if database initialization was successful
    const app = express();
    // Configure Passport's Local Strategy
    passport.use(new LocalStrategy({
        usernameField: 'email',
        passwordField: 'password'
    }, async (email, password, done) => {
        try {
            console.log('[Passport] Authenticating user:', { email });
            const result = await db
                .select()
                .from(users)
                .where(sql `LOWER(${users.email}) = LOWER(${email})`)
                .limit(1);
            const user = result[0];
            if (!user) {
                console.log('[Passport] User not found:', { email });
                return done(null, false, { message: 'Invalid email or password.' });
            }
            const isValid = await bcrypt.compare(password, user.password);
            if (!isValid) {
                console.log('[Passport] Invalid password:', { email });
                return done(null, false, { message: 'Invalid email or password.' });
            }
            // Remove password from user object before serializing
            const { password: _, ...userWithoutPassword } = user;
            console.log('[Passport] Authentication successful:', { userId: user.id });
            return done(null, userWithoutPassword);
        }
        catch (err) {
            console.error('[Passport] Authentication error:', err);
            return done(err);
        }
    }));
    // Serialize user for the session
    passport.serializeUser((user, done) => {
        console.log('[Passport] Serializing user:', { userId: user.id });
        done(null, user.id);
    });
    // Deserialize user from the session
    passport.deserializeUser(async (id, done) => {
        try {
            console.log('[Passport] Deserializing user:', { userId: id });
            const result = await db
                .select()
                .from(users)
                .where(eq(users.id, id))
                .limit(1);
            if (!result[0]) {
                console.log('[Passport] User not found during deserialization:', { userId: id });
                return done(null, false);
            }
            // Remove password before returning
            const { password: _, ...userWithoutPassword } = result[0];
            console.log('[Passport] User deserialized successfully:', { userId: id });
            done(null, userWithoutPassword);
        }
        catch (err) {
            console.error('[Passport] Deserialization error:', err);
            done(err);
        }
    });
    // CORS configuration
    const allowedOrigins = [
        'http://localhost:5173',
        'http://localhost:3001',
        'http://0.0.0.0:5173',
        'http://0.0.0.0:3001',
        'http://172.31.196.3:5173',
        'http://172.31.196.62:5173',
        'http://172.31.196.85:5173',
        'http://172.31.196.5:5173',
        'https://endorsehub.replit.app',
        'https://endorsehub.com',
        'https://www.endorsehub.com',
        /\.replit\.dev$/,
        /\.replit\.app$/,
        /^https?:\/\/.*\.worf\.replit\.dev(:\d+)?$/
    ];
    // Add CLIENT_URL if it exists
    if (process.env.CLIENT_URL) {
        allowedOrigins.push(process.env.CLIENT_URL);
    }
    const corsOptions = {
        origin: (origin, callback) => {
            // Allow requests with no origin (like mobile apps, curl requests, or same-origin)
            if (!origin) {
                return callback(null, true);
            }
            // Check if the origin is allowed
            const isAllowed = allowedOrigins.some(allowed => {
                if (typeof allowed === 'string') {
                    return allowed === origin;
                }
                // For RegExp, test the origin
                return allowed.test(origin);
            });
            if (isAllowed) {
                callback(null, true);
            }
            else {
                console.warn(`[CORS] Blocked request from origin: ${origin}`);
                callback(new Error('Not allowed by CORS'));
            }
        },
        credentials: true,
        methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
        allowedHeaders: ['Content-Type', 'Authorization', 'Cookie', 'stripe-signature'],
        exposedHeaders: ['Set-Cookie'],
        maxAge: 86400 // 24 hours in seconds
    };
    // Basic middleware
    app.use(cors(corsOptions));
    // Stripe webhook needs raw body parsing - must come before JSON middleware
    app.post('/api/billing/webhook', express.raw({ type: 'application/json' }), async (req, res) => {
        console.log('[Stripe Webhook] Received webhook request:', {
            path: req.path,
            method: req.method,
            hasSignature: !!req.headers['stripe-signature'],
            contentType: req.headers['content-type'],
            bodyType: typeof req.body,
            bodyLength: req.body?.length
        });

        try {
            await handleWebhook(req, res);
        } catch (error) {
            console.error('[Stripe Webhook] Error:', error);
            return res.status(400).json({ 
                error: 'Webhook error',
                message: error instanceof Error ? error.message : 'Unknown error'
            });
        }
    });
    // Body parsing middleware for all other routes
    app.use(express.json());
    app.use(express.urlencoded({ extended: true }));
    // Session setup
    const MemoryStoreSession = MemoryStore(session);
    const sessionConfig = {
        secret: process.env.SESSION_SECRET || crypto.randomBytes(32).toString('hex'),
        name: 'testimonial.sid',
        resave: false,
        saveUninitialized: false,
        rolling: true,
        store: new MemoryStoreSession({
            checkPeriod: 86400000
        }),
        cookie: {
            secure: process.env.NODE_ENV === 'production',
            httpOnly: true,
            sameSite: 'lax',
            maxAge: 24 * 60 * 60 * 1000,
            path: '/'
        }
    };
    // In production, ensure secure cookies and trust proxy
    if (process.env.NODE_ENV === 'production') {
        app.set('trust proxy', 1);
        app.enable('trust proxy');
    }
    app.use(session(sessionConfig));
    // Initialize Passport
    app.use(passport.initialize());
    app.use(passport.session());
    // Debug middleware for all requests
    app.use((req, res, next) => {
        console.log('[Server] Request:', {
            method: req.method,
            path: req.path,
            origin: req.get('origin'),
            authenticated: req.isAuthenticated(),
            userId: req.user?.id,
            sessionId: req.session?.id
        });
        next();
    });
    // API routes
    console.log('[Server] Setting up API routes...');
    const router = express.Router();
    // Setup auth first
    setupAuthRoutes(router);
    // Then other routes
    setupTestimonialRoutes(router);
    setupAnalyticsRoutes(router);
    setupStripeRoutes(router);
    setupWidgetRoutes(router);
    setupStatsRoutes(router);
    // Mount API routes at /api
    app.use('/api', router);
    console.log('[Server] API routes mounted at /api');
    // Serve static files from the client build directory
    const clientDistPath = path.join(__dirname, '..', 'client', 'dist');
    app.use(express.static(clientDistPath));
    // SPA fallback - this must come after API routes
    app.get('*', (req, res) => {
        // Don't handle /api routes here
        if (req.path.startsWith('/api/')) {
            return res.status(404).json({
                success: false,
                error: 'API endpoint not found'
            });
        }
        res.sendFile(path.join(clientDistPath, 'index.html'));
    });
    // Error handling middleware - should be last
    app.use((err, req, res, next) => {
        console.error('[Server] Error:', err);
        res.status(err.status || 500).json({
            success: false,
            error: err.message || 'Internal Server Error'
        });
    });
    const port = parseInt(process.env.PORT || '3001', 10);
    app.listen(port, '0.0.0.0', () => {
        console.log(`[Server] API Server running at http://0.0.0.0:${port}`);
    });
}
// Improve error handling in the main startup function
process.on('unhandledRejection', (reason, promise) => {
    console.error('[Server] Unhandled Rejection at:', promise, 'reason:', reason);
    process.exit(1);
});
startServer().catch(error => {
    console.error('[Server] Fatal startup error:', error);
    process.exit(1);
});